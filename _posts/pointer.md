---
layout: post
title: "C++ 指针"
subtitle: ""
date: 2019-03-26
author: 超鹏
category: C++
tags: C++,指针
finished: false
---
#C++ 指针

##指针

**指针**(pointer)是“指向(point to)”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有许多不同点。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无须在定义时赋初始值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

定义指针类型的方式是将声明符写成 \*d 的形式，其中 d 是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号 \*。

```c++
    int *ip1, *ip2;      // ip 和 ip2 都是指向 int 型对象的指针
    double dp, *dp2;     // dp2 是指向 double 型对象的指针，dp 是 double 型对象
```

###获取对象的地址

指针存放某个对象的地址，想要获取该地址，需要使用**取地址符**（操作符 & ）：

```c++
    int ival = 42;
    int *p = &ival;    //p 存放变量 ival 的地址，或者说 p 是指向变量 ival 的指针

    double dval;
    double *pd = &dval;    //正确：初始值是 double 型对象的地址
    double *pd2 = pd;      //正确：初始值是指向 double 对象的指针

    int *pi = pd;          //错误：指针 pi 的类型和 pd 的类型不匹配
    pi = &dval;            //错误：试图把 double 型对象的地址赋给 int 型指针
```

###利用指针访问对象

如果指针指向了一个对象，则允许使用**解引用符**（操作符 * ）来访问该对象：

```c++
    int ival = 42;
    int *p = &ival;       // p 存放着变量 ival 的地址，或者说 p 是指向变量 ival 的指针
    cout << *p ;          //由符号 * 得到指针 p 所指的对象，输出 42

    *p = 0;               //由符号 * 得到指针 p 所指的对象，即可经由 p 为变量 ival 赋值
    cout << *p;           // 输出0
```

某些符号有多重含义：
```c++
    int i = 42;         
    int &r = i;        // &紧随类型名出现，因此是声明的一部分，r 是一个引用
    int *p;              // *紧随类型名出现，因此是声明的一部分，p 是一个指针
    p = &i;             // &出现在表达式中，是一个取地址符
    *p = i;             // *出现在表达式中，是一个解引用符
    int &r2 = *p;           // &是声明的一部分，* 是一个解引用符
```

###空指针

**空指针**（null pointer）不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：

```c++
    int *p1 = nullptr;          //等价与 int * p1 = 0;
    int *p2 = 0;                //直接将 p2 初始化为字面常量 0 
    // 需要首先#include cstdlib
    int *p3 = NULL;             //等价于 int *p3 = 0;
```

得到空指针最直接的办法就是用字面值 **nullptr** 来初始化指针。

把 int 变量直接赋给指针是错误的操作，即使 int 变量的值恰好等于 0 也不行。

```c++
    int zero = 0;
    pi = zero;          //错误：不能把 int 变量直接赋值给指针
```

>建议：初始化所有指针
